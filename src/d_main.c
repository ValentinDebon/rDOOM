//-----------------------------------------------------------------------------
//
// Copyright (C) 1993-1996 by id Software, Inc.
// Copyright (C) 2020 by Valentin Debon.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------

#include <unistd.h>

#include "doomstat.h"

#include "d_main.h"

#include "am_map.h"
#include "f_finale.h"
#include "f_wipe.h"
#include "g_game.h"
#include "hu_stuff.h"
#include "i_error.h"
#include "i_sound.h"
#include "i_system.h"
#include "i_video.h"
#include "l_strings.h"
#include "m_array.h"
#include "m_menu.h"
#include "m_misc.h"
#include "m_param.h"
#include "p_setup.h"
#include "r_local.h"
#include "s_sound.h"
#include "st_stuff.h"
#include "v_video.h"
#include "wi_stuff.h"
#include "z_zone.h"

M_TemplateArray(Wadfile, const char *, 4);

static struct d_main {
	struct m_arrayWadfile wadfiles;
} d_main;

bool singletics = false; // debug flag to cancel adaptiveness
bool autostart = false;

int devparm;     // started game with -devparm
int nomonsters;  // checkparm of -nomonsters
int respawnparm; // checkparm of -respawn
int fastparm;    // checkparm of -fast

skill_t startskill;
int startepisode;
int startmap;

FILE *debugfile;

bool advancedemo;

void
D_CheckNetGame(void);
void
D_ProcessEvents(void);
void
G_BuildTiccmd(ticcmd_t *cmd);
void
D_DoAdvanceDemo(void);

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t events[MAXEVENTS];
int eventhead;
int eventtail;

//
// D_PostEvent
// Called by the I/O functions when input is detected
//
void
D_PostEvent(const event_t *ev) {
	events[eventhead] = *ev;
	++eventhead;
	eventhead = eventhead & (MAXEVENTS - 1);
}

//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//
void
D_ProcessEvents(void) {
	event_t *ev;

	// IF STORE DEMO, DO NOT ACCEPT INPUT
	if((gamemode == commercial)
		&& (W_FindIdForName("map01") < 0))
		return;

	for(; eventtail != eventhead; ++eventtail, eventtail = eventtail & (MAXEVENTS - 1)) {
		ev = &events[eventtail];
		if(M_Responder(ev))
			continue; // menu ate the event
		G_Responder(ev);
	}
}

//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t wipegamestate = GS_DEMOSCREEN;
extern bool setsizeneeded;
extern int showMessages;
void
R_ExecuteSetViewSize(void);

void
D_Display(void) {
	extern bool inhelpscreens;
	static bool viewactivestate    = false;
	static bool menuactivestate    = false;
	static bool inhelpscreensstate = false;
	static bool fullscreen         = false;
	static gamestate_t oldgamestate   = -1;
	static int borderdrawcount;
	int nowtime;
	int tics;
	int wipestart;
	int y;
	bool done;
	bool wipe;
	bool redrawsbar;

	if(nodrawers)
		return; // for comparative timing / profiling

	redrawsbar = false;

	// change the view size if needed
	if(setsizeneeded) {
		R_ExecuteSetViewSize();
		oldgamestate    = -1; // force background redraw
		borderdrawcount = 3;
	}

	// save the current screen if about to wipe
	if(gamestate != wipegamestate) {
		wipe = true;
		wipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);
	} else
		wipe = false;

	if(gamestate == GS_LEVEL && gametic)
		HU_Erase();

	// do buffered drawing
	switch(gamestate) {
	case GS_LEVEL:
		if(!gametic)
			break;
		if(automapactive)
			AM_Drawer();
		if(wipe || (viewheight != 200 && fullscreen))
			redrawsbar = true;
		if(inhelpscreensstate && !inhelpscreens)
			redrawsbar = true; // just put away the help screen
		ST_Drawer(viewheight == 200, redrawsbar);
		fullscreen = viewheight == 200;
		break;

	case GS_INTERMISSION:
		WI_Drawer();
		break;

	case GS_FINALE:
		F_Drawer();
		break;

	case GS_DEMOSCREEN:
		D_PageDrawer();
		break;
	}

	// draw buffered stuff to screen
	I_UpdateNoBlit();

	// draw the view directly
	if(gamestate == GS_LEVEL && !automapactive && gametic)
		R_RenderPlayerView(&players[displayplayer]);

	if(gamestate == GS_LEVEL && gametic)
		HU_Drawer();

	// clean up border stuff
	if(gamestate != oldgamestate && gamestate != GS_LEVEL)
		I_SetPalette(W_LumpForName("PLAYPAL")->data);

	// see if the border needs to be initially drawn
	if(gamestate == GS_LEVEL && oldgamestate != GS_LEVEL) {
		viewactivestate = false; // view was not active
		R_FillBackScreen();      // draw the pattern into the back screen
	}

	// see if the border needs to be updated to the screen
	if(gamestate == GS_LEVEL && !automapactive && scaledviewwidth != 320) {
		if(menuactive || menuactivestate || !viewactivestate)
			borderdrawcount = 3;
		if(borderdrawcount) {
			R_DrawViewBorder(); // erase old menu stuff
			borderdrawcount--;
		}
	}

	menuactivestate    = menuactive;
	viewactivestate    = viewactive;
	inhelpscreensstate = inhelpscreens;
	oldgamestate = wipegamestate = gamestate;

	// draw pause pic
	if(paused) {
		if(automapactive)
			y = 4;
		else
			y = viewwindowy + 4;
		V_DrawPatchDirect(viewwindowx + (scaledviewwidth - 68) / 2,
			y,
			0,
			W_LumpForName("M_PAUSE")->data);
	}

	// menus go directly to the screen
	M_Drawer();  // menu is drawn even on top of everything
	NetUpdate(); // send out any new accumulation

	// normal update
	if(!wipe) {
		I_FinishUpdate(); // page flip or blit buffer
		return;
	}

	// wipe update
	wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);

	wipestart = I_GetTime() - 1;

	do {
		do {
			nowtime = I_GetTime();
			tics    = nowtime - wipestart;
		} while(!tics);
		wipestart = nowtime;
		done      = wipe_ScreenWipe(wipe_Melt, 0, 0, SCREENWIDTH, SCREENHEIGHT, tics);
		I_UpdateNoBlit();
		M_Drawer();       // menu is drawn even on top of wipes
		I_FinishUpdate(); // page flip or blit buffer
	} while(!done);
}

/*
 * D_DoomLoop()
 * Manages timing and IO,
 *  calls all ?_Responder, ?_Ticker, and ?_Drawer,
 *  calls I_GetTime, I_StartFrame, and I_StartTic
 */
static void
D_DoomLoop(void) {
	extern bool demorecording;

	if(demorecording)
		G_BeginRecording();

	if(M_CheckParam("debugfile")) {
		const char *filename = M_Format(NULL, "debug%i.txt", consoleplayer);
		printf("Debug output to: %s\n", filename);
		debugfile = fopen(filename, "w");
	}

	I_InitGraphics();

	while(1) {
		// frame syncronous IO operations
		I_StartFrame();

		// process one or more tics
		if(singletics) {
			I_StartTic();
			D_ProcessEvents();
			G_BuildTiccmd(&netcmds[consoleplayer][maketic % BACKUPTICS]);
			if(advancedemo)
				D_DoAdvanceDemo();
			M_Ticker();
			G_Ticker();
			gametic++;
			maketic++;
		} else {
			TryRunTics(); // will run at least one tic
		}

		S_UpdateSounds(players[consoleplayer].mo); // move positional sounds

		// Update display, next frame, with current state.
		D_Display();

#ifndef SNDSERV
		// Sound mixing for the buffer is snychronous.
		I_UpdateSound();
#endif
		// Synchronous sound output is explicitly called.
#ifndef SNDINTR
		// Update sound output.
		I_SubmitSound();
#endif
	}
}

//
//  DEMO LOOP
//
int demosequence;
int pagetic;
char *pagename;

//
// D_PageTicker
// Handles timing for warped projection
//
void
D_PageTicker(void) {
	if(--pagetic < 0)
		D_AdvanceDemo();
}

//
// D_PageDrawer
//
void
D_PageDrawer(void) {
	V_DrawPatch(0, 0, 0, W_LumpForName(pagename)->data);
}

//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//
void
D_AdvanceDemo(void) {
	advancedemo = true;
}

//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//
void
D_DoAdvanceDemo(void) {
	players[consoleplayer].playerstate = PST_LIVE; // not reborn
	advancedemo                        = false;
	usergame                           = false; // no save / end game here
	paused                             = false;
	gameaction                         = ga_nothing;

	if(gamemode == retail)
		demosequence = (demosequence + 1) % 7;
	else
		demosequence = (demosequence + 1) % 6;

	switch(demosequence) {
	case 0:
		if(gamemode == commercial)
			pagetic = 35 * 11;
		else
			pagetic = 170;
		gamestate = GS_DEMOSCREEN;
		pagename  = "TITLEPIC";
		if(gamemode == commercial)
			S_StartMusic(mus_dm2ttl);
		else
			S_StartMusic(mus_intro);
		break;
	case 1:
		G_DeferedPlayDemo("demo1");
		break;
	case 2:
		pagetic   = 200;
		gamestate = GS_DEMOSCREEN;
		pagename  = "CREDIT";
		break;
	case 3:
		G_DeferedPlayDemo("demo2");
		break;
	case 4:
		gamestate = GS_DEMOSCREEN;
		if(gamemode == commercial) {
			pagetic  = 35 * 11;
			pagename = "TITLEPIC";
			S_StartMusic(mus_dm2ttl);
		} else {
			pagetic = 200;

			if(gamemode == retail)
				pagename = "CREDIT";
			else
				pagename = "HELP2";
		}
		break;
	case 5:
		G_DeferedPlayDemo("demo3");
		break;
		// THE DEFINITIVE DOOM Special Edition demo
	case 6:
		G_DeferedPlayDemo("demo4");
		break;
	}
}

//
// D_StartTitle
//
void
D_StartTitle(void) {
	gameaction   = ga_nothing;
	demosequence = -1;
	D_AdvanceDemo();
}

static void
D_AddFile(const char *file) {
	M_ArrayWadfileAppend(&d_main.wadfiles, strdup(file));
}

static bool
D_FindVersion(const char *doomwaddir, const char *wadfile, enum d_gameMode versionmode) {
	const char * const path = M_Format(NULL, "%s/%s", doomwaddir, wadfile);
	const bool found = access(path, R_OK) == 0;

	if(found) {
		gamemode = versionmode;
		D_AddFile(path);
	}

	return found;
}

/*
 * D_IdentifyVersion
 * Checks availability of IWAD files by name,
 * to determine whether registered/commercial features
 * should be executed (notably loading PWAD's).
 */
static void
D_IdentifyVersion(void) {

	if(M_CheckParam("shdev")) {
		gamemode = shareware;
		devparm  = true;
		D_AddFile(DEVDATA "doom1.wad");
		D_AddFile(DEVMAPS "data_se/texture1.lmp");
		D_AddFile(DEVMAPS "data_se/pnames.lmp");
		return;
	}

	if(M_CheckParam("regdev")) {
		gamemode = registered;
		devparm  = true;
		D_AddFile(DEVDATA "doom.wad");
		D_AddFile(DEVMAPS "data_se/texture1.lmp");
		D_AddFile(DEVMAPS "data_se/texture2.lmp");
		D_AddFile(DEVMAPS "data_se/pnames.lmp");
		return;
	}

	if(M_CheckParam("comdev")) {
		gamemode = commercial;
		devparm  = true;
		D_AddFile(DEVDATA "doom2.wad");
		D_AddFile(DEVMAPS "cdata/texture1.lmp");
		D_AddFile(DEVMAPS "cdata/pnames.lmp");
		return;
	}

	const char *doomwaddir = getenv("DOOMWADDIR");
	if(doomwaddir == NULL) {
		doomwaddir = ".";
	}

	if(D_FindVersion(doomwaddir, "doom2f.wad", commercial)) {
		/* C'est ridicule! */
		/* Let's handle languages in config files, okay? */
		L_SetCurrentLanguage(LANGUAGE_FRENCH);
		printf("French version\n");
		return;
	}

	if(D_FindVersion(doomwaddir, "doom2.wad", commercial)) {
		return;
	}

	if(D_FindVersion(doomwaddir, "plutonia.wad", commercial)) {
		return;
	}

	if(D_FindVersion(doomwaddir, "tnt.wad", commercial)) {
		return;
	}

	if(D_FindVersion(doomwaddir, "doomu.wad", retail)) {
		return;
	}

	if(D_FindVersion(doomwaddir, "doom.wad", registered)) {
		return;
	}

	if(D_FindVersion(doomwaddir, "doom1.wad", shareware)) {
		return;
	}

	printf("Game mode indeterminate.\n");
	gamemode = indetermined;

	/* We don't abort. Let's see what the PWAD contains. */
}

//
// D_DoomMain
//
void
D_DoomMain(char **files, char **filesend) {

	D_IdentifyVersion();

	setbuf(stdout, NULL);
	modifiedgame = false;

	nomonsters  = M_CheckParam("nomonsters");
	respawnparm = M_CheckParam("respawn");
	fastparm    = M_CheckParam("fast");
	devparm     = M_CheckParam("devparm");

	if(M_CheckParam("altdeath")) {
		deathmatch = 2;
	} else if(M_CheckParam("deathmatch")) {
		deathmatch = 1;
	}

	const char *title;
	switch(gamemode) {
	case retail:
		title = "The Ultimate DOOM Startup";
		break;
	case shareware:
		title = "DOOM Shareware Startup";
		break;
	case registered:
		title = "DOOM Registered Startup";
		break;
	case commercial:
		title = "DOOM 2: Hell on Earth";
		break;
#if 0
	case pack_plut:
		title = "DOOM 2: Plutonia Experiment";
		break;
	case pack_tnt:
		title = "DOOM 2: TNT - Evilution";
		break;
#endif
	default:
		title = "Public DOOM -";
		break;
	}

	printf("%s v%i.%i\n", title, VERSION / 100, VERSION % 100);

	if(devparm) {
		fputs(L_String(STRING_D_DEVSTR), stdout);
	}

	/****************
	 * turbo option *
	 ****************/
	int scale;
	if(M_GetNumericParam("turbo", 10, 400, &scale)) {
		extern int forwardmove[2];
		extern int sidemove[2];

		printf("turbo scale: %i%%\n", scale);
		forwardmove[0] = forwardmove[0] * scale / 100;
		forwardmove[1] = forwardmove[1] * scale / 100;
		sidemove[0]    = sidemove[0] * scale / 100;
		sidemove[1]    = sidemove[1] * scale / 100;
	}

	/********************************************************
	 * Add any files specified after command line arguments *
	 ********************************************************/
	if(files != filesend) {
		modifiedgame = true;
		do {
			D_AddFile(*files);
			files++;
		} while(files != filesend);
	}

	/********
	 * Demo *
	 ********/
	const char *demolump = NULL;

	M_GetValueParam("playdemo", &demolump);
	M_GetValueParam("timedemo", &demolump);

	if(demolump != NULL) {
		static const char lumpextension[] = ".lmp";
		const size_t demolumplen = strlen(demolump);
		char demolumpfile[demolumplen + sizeof(lumpextension)];

		strncpy(demolumpfile, demolump, demolumplen);
		strcpy(demolumpfile + demolumplen, lumpextension);
		printf("Playing demo %s.\n", demolumpfile);

		D_AddFile(demolumpfile);
	}

	/*******************************************
	 * Get skill, episode, map from parameters *
	 *******************************************/

	int startskill_ = sk_medium;
	if(M_GetNumericParam("skill", 0, 4, &startskill_)) {
		startskill = startskill_;
		autostart = true;
	}

	int startepisode_ = 1;
	if(M_GetNumericParam("episode", 1, INT_MAX, &startepisode_)) {
		startepisode = startepisode_;
		startmap = 1;
		autostart = true;
	}

	int startmap_ = 1;
	if(M_GetNumericParam("warp", 1, INT_MAX, &startmap_)) {
		startmap = startmap_;
		autostart = true;
	}

	int timer;
	if(M_GetNumericParam("timer", 1, INT_MAX, &timer) && deathmatch) {
		printf("Levels will end after %d minute", timer);
		if(timer > 1) {
			fputc('s', stdout);
		}
		puts(".");
	}

	if(M_CheckParam("avg") && deathmatch) {
		puts("Austin Virtual Gaming: Levels will end after 20 minutes");
	}

	/*******************
	 * Init subsystems *
	 *******************/

	puts("V_Init: Allocate screens.");
	V_Init();

	puts("M_LoadDefaults: Load system defaults.");
	M_LoadDefaults(); /* Load before initing other systems */

	puts("Z_Init: Init zone memory allocation daemon.");
	Z_Init();

	puts("W_Init: Init WADfiles.");
	W_Init(d_main.wadfiles.begin, d_main.wadfiles.end);

	if(modifiedgame) {
		/* Check for additional files in shareware */
		if(gamemode == shareware) {
			I_Error("You cannot add additional files with the shareware version. Register!");
		}

		/* Check for fake IWAD with right name,
		 * but w/o all the lumps of the registered version. */
		if(gamemode == registered) {
			/* These are the lumps that will be checked in IWAD,
			 * if any one is not present, execution will be aborted. */
			const char name[][8] = {
				"e2m1", "e2m2", "e2m3", "e2m4", "e2m5", "e2m6", "e2m7", "e2m8", "e2m9",
				"e3m1", "e3m3", "e3m3", "e3m4", "e3m5", "e3m6", "e3m7", "e3m8", "e3m9",
				"dphoof", "bfgga0", "heada1", "cybra1", "spida1d1",
			};

			for(int i = 0; i < sizeof(name) / sizeof(*name); i++) {
				if(W_FindIdForName(name[i]) < 0) {
					I_Error("This is not the registered version.");
				}
			}
		}

		/* If additional PWAD files are used, print modified banner */
		puts(
			"===========================================================================\n"
			"ATTENTION:  This version of DOOM has been modified.  If you would like to\n"
			"get a copy of the original game, call 1-800-IDGAMES or see the readme file.\n"
			"        You will not receive technical support for modified games.\n"
			"==========================================================================="
		);
	}

	/* Check and print which version is executed. */
	switch(gamemode) {
	case shareware:
	case indetermined:
		puts(
			"===========================================================================\n"
			"                                Shareware!\n"
			"==========================================================================="
		);
		break;
	case registered:
	case retail:
	case commercial:
		puts(
			"===========================================================================\n"
			"                 Commercial product - do not distribute!\n"
			"         Please report software piracy to the SPA: 1-800-388-PIR8\n"
			"==========================================================================="
		);
		break;
	default:
		/* Ouch. */
		break;
	}

	puts("M_Init: Init miscellaneous info.");
	M_Init();

	puts("R_Init: Init DOOM refresh daemon");
	R_Init();

	puts("P_Init: Init Playloop state.");
	P_Init();

	puts("I_Init: Setting up machine state.");
	I_Init();

	puts("D_CheckNetGame: Checking network game status.");
	D_CheckNetGame();

	puts("S_Init: Setting up sound.");
	S_Init(snd_SfxVolume /* *8 */, snd_MusicVolume /* *8*/);

	puts("HU_Init: Setting up heads up display.");
	HU_Init();

	puts("ST_Init: Init status bar.");
	ST_Init();

	/**************************************************
	 * Start the appropriate game based on parameters *
	 **************************************************/

	const char *record;
	if(M_GetValueParam("record", &record)) {
		G_RecordDemo(record);
		autostart = true;
	}

	if(M_CheckParam("playdemo")) {
		singledemo = true; /* quit after one demo */
		G_DeferedPlayDemo(demolump);
		D_DoomLoop();
	}

	if(M_CheckParam("timedemo")) {
		G_TimeDemo(demolump);
		D_DoomLoop();
	}

	int saveno;
	if(M_GetNumericParam("loadgame", 0, 5, &saveno)) {
		char savefile[] = SAVEGAMENAME "0.dsg";

		savefile[sizeof(savefile) - 6] += saveno;

		G_LoadGame(savefile);
	}

	if(gameaction != ga_loadgame) {
		if(autostart || netgame) {
			G_InitNew(startskill, startepisode, startmap);
		} else {
			D_StartTitle(); /* Start up intro loop */
		}
	}

	D_DoomLoop(); /* Never returns */
}
